# Copyright 2011 Johan Rydberg
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from twisted.application import service
from twisted.web import server, resource
import txgossip
from nosio import rest


class KeyStoreParticipant(object):
    """Example showing a simple key-value store with eventual
    consistency.

    Each value is annotated with a timestamp.  When there's two
    conflicting changes, the one with the latest timestamp wins.

    The implementation expects all participants to have synced clocks.
    """

    def __init__(self, clock, storage):
        self.clock = clock
        self.storage = storage
        self._watches = {}

    def value_changed(self, peer, key, timestamp_value):
        if key == '__heartbeat__':
            # We do not care about updates to the heartbeat value.
            return
        print self.gossiper.name, "got", key
        timestamp, value = timestamp_value
        if key in self.storage:
            current_timestamp, current_value = self.storage[key]
            if timestamp <= current_timestamp:
                return
        self.storage[key] = (timestamp, value)
        for pattern, callback in self._watches.items():
            if key == pattern:
                callback(value)

    def __setitem__(self, key, value):
        self.gossiper.set_local_state(key,
            (self.clock.seconds(), value))

    def __getitem__(self, key):
        return self.storage[key][1]

    def __contains__(self, key):
        return key in self.storage

    def get(self, key, default=None):
        if key in self.storage:
            return self[key]
        return default

    def watch(self, keypattern, callback):
        self._watches[keypattern] = callback

    def peer_alive(self, peer):
        """The gossip tells us that there's a new peer."""
        for key in self.gossiper.get_peer_keys(peer):
            self.value_changed(peer, key, self.gossiper.get_peer_value(
                    peer, key))

    def peer_dead(self, peer):
        """The gossip tells us that there's a peer down."""

    def keys(self):
        """Return a iterable of all available keys."""
        return self.gossiper.keys()


class ApplicationController:

    def __init__(self, keystore):
        self.keystore = keystore

    def put(self, request, url, appname=None):
        """Update application configuration."""
        config = rest.read_json(request)
        for required in ('name', 'configuration',):
            if not required in config:
                raise rest.ControllerError(400)

        key = 'app:%s' % appname
        timestamp = str(datetime.datetime.fromtimestamp(
                self.clock.seconds()))

        response_code = 200
        if not key in self.keystore:
            response_code=201
            config['created_at'] = timestamp
        config['updated_at'] = timestamp
        config['name'] = appname

        rest.write_json(request, config, rc=response_code)
    post = put

    def get(self, request, url, appname=None):
        """Read out application configuration."""
        key = 'app:%s' % appname
        try:
            config = self.keystore[key]
        except KeyError:
            raise rest.NoSuchResourceError()
        rest.write_json(request, config)


class ApplicationCollectionController:

    def __init__(self, keystore):
        self.keystore = keystore

    def get(self, request, url):
        """Read out application configuration."""
        apps = []
        for key in self.keystore.keys():
            if key.startswith('app:'):
                apps.append(self.keystore[key])
        rest.write_json(request, {'apps': apps})


class ServiceHostController:

    def __init__(self, keystore):
        self.keystore = keystore

    def get(self, request, url, srvname=None, hostname=None):
        if hostname == ':master':
            master_key = 'srv:%s:__master__' % srvname
            if not master_key in self.keystore:
                raise rest.NoSuchResourceError()
            hostname = self.keystore[master_key]
        key = 'srv:%s:%s' % (srvname, hostname)
        if key not in self.keystore:
            raise rest.NoSuchResourceError()

        config = dict(self.keystore[key])
        rest.write_json(request, config)

    def put(self, request, url, srvname=None, hostname=None):
        """.
        """
        for required in ('name', 'configuration',):
            if not required in config:
                raise rest.ControllerError(400)
        data = read_json(request)
        update_master = hostname == ':master'
        if update_master:
            hostname = data['name']

        key = 'srv:%s:%s' % (srvname, hostname)
        timestamp = self.clock.seconds()
        data['updated_at'] = timestamp
        if not key in self.keystore:
            data['created_at'] = timestamp
        self.keystore[key] = data

            master_key = 'srv:%s:__master__' % srvname
            if self.keystore.get(master_key) != hostname:
                self.keystore[master_key] = hostname

        rest.write_json(request, config)


class ServiceController:

    def __init__(self, keystore):
        self.keystore = keystore

    def get(self, request, url, srvname=None):
        key = 'srv:%s:' % srvname
        for key in self.keystore.keys():
            if key == 'srv:%s:__master__' % srvname:
                # ignore the master record.
                continue
            if key.startswith(srvname):
                apps.append(self.keystore[key])
                

        key = 'srv:%s' % appname
        try:
            config = self.keystore[key]
        except KeyError:
            raise rest.NoSuchResourceError()
        rest.write_json(request, config)




class Lemek(service.Service):

    def __init__(self, reactor, listen_addr, listen_port):
        service.Service.__init__(self)
        self.reactor = reactor
        self._listen_port = listen_port
        self.participant = Participant(reactor)
        self._protocol = txgossip.Gossiper(reactor, '%s:%d' % (
                listen_addr, listen_port), self.participant)

    def startService(self):
        self.reactor.listenUDP(self._listen_port, self._protocol)
        self.reactor.listenTCP(self._listen_port, server.Site(
                self._resource))
